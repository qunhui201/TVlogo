name: 智能增量同步到 Cloudflare KV（公开仓库专用）

on:
  workflow_dispatch:
  push:
    branches: [ main, master ]

jobs:
  sync:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout 仓库
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: 终极安全上传（防 malformed + 防 429）
        env:
          ACCOUNT_ID: ${{ secrets.KV_ACCOUNT_ID }}
          NAMESPACE_ID: ${{ secrets.KV_NAMESPACE_ID }}
          API_TOKEN: ${{ secrets.KV_API_TOKEN }}
        run: |
          # 安装 jq
          sudo apt-get update && sudo apt-get install -y jq

          # 1. 找出 git 这次真正改动的文件
          CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "")

          # 2. 强制每次都上传的核心文件（每行一个！）
          cat > force.txt << 'EOF'
          output.m3u
          output_with_logo.m3u
          tvbox_output.txt
          missing_logos.txt
          README.md
          EOF

          # 3. 强制上传所有 merged 文件
          find history -maxdepth 1 -name "merged.*" -type f | sed 's|^\./||' > merged.txt 2>/dev/null || true

          # 4. 合并 + 去重 → 最终要上传的列表
          {
            echo "$CHANGED"
            cat force.txt
            cat merged.txt
          } | grep -v "^$" | sort -u > upload_list.txt

          # 如果没东西要传就直接结束
          if [ ! -s upload_list.txt ]; then
            echo "没有需要上传的文件，本次结束"
            exit 0
          fi

          echo "本次将上传 $(wc -l < upload_list.txt) 个文件："
          cat upload_list.txt | sed 's/^/  → /'

          # 5. 开始上传（每文件独立处理，永不 malformed）
          SUCCESS=0
          FAIL=0
          while IFS= read -r file; do
            [[ -f "$file" ]] || continue

            # 清理路径（去掉开头的 ./）
            KEY=$(echo "$file" | sed 's|^\./||')
            ENCODED=$(printf '%s' "$KEY" | jq -Rr @uri)

            echo "正在上传 → $KEY"

            for i in 1 2 3; do
              if curl -X PUT \
                "https://api.cloudflare.com/client/v4/accounts/$ACCOUNT_ID/storage/kv/namespaces/$NAMESPACE_ID/values/$ENCODED" \
                -H "Authorization: Bearer $API_TOKEN" \
                -H "Content-Type: text/plain" \
                --data-binary @"$file" \
                --fail --silent --show-error; then
                echo "上传成功！"
                ((SUCCESS++))
                break
              else
                echo "第 $i 次失败，等待重试..."
                sleep $((i * 8))
              fi
            done

            sleep 2.5
            (( $(wc -l < upload_list.txt) - SUCCESS - FAIL > 0 && (SUCCESS + FAIL) % 3 == 0 )) && sleep 15

          done < upload_list.txt

          echo "=========================================="
          echo "全部完成！成功 $SUCCESS，失败 $FAIL"
          echo "=========================================="
