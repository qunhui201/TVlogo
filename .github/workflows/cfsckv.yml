# =======================================================
# 【重要调试】使用 set -eux 模式运行，让 Bash 打印每一步
# 当脚本退出时，你就能看到是哪一行命令出错了
# =======================================================
set -eux

# 1. 变量清洗：去除 Secrets 中的隐藏空格和换行符
ACCOUNT_ID=$(echo "$RAW_ACCOUNT_ID" | tr -d '[:space:]')
NAMESPACE_ID=$(echo "$RAW_NAMESPACE_ID" | tr -d '[:space:]')
API_TOKEN=$(echo "$RAW_API_TOKEN" | tr -d '[:space:]')

# 检查配置
if [[ -z "$ACCOUNT_ID" || -z "$NAMESPACE_ID" || -z "$API_TOKEN" ]]; then
  echo "❌ 错误: Secrets 未配置或为空，跳过上传步骤。"
  exit 0
fi

LIST_FILE="kv_uploaded_history.txt"
touch "$LIST_FILE"

# 1. 强制上传的文件（根目录全部 + history/merged.*）
: > force_upload.txt
# 注意：find 命令的结果可能带有 './'，后续处理会移除
find . -maxdepth 1 -type f -regex '.*\.\(txt\|m3u\|m3u8\|md\|json\)' -print >> force_upload.txt
find history -maxdepth 1 -name "merged.*" -print >> force_upload.txt 2>/dev/null || true

# 2. history/ 下所有归档文件（排除 merged.*）
find history -type f ! -name "merged.*" | sort > history_all.txt

# 3. 对比历史清单，找出真正的新归档文件
# 使用 || true 确保 comm 命令找不到文件时不会退出脚本
comm -23 history_all.txt <(sort "$LIST_FILE" 2>/dev/null || true) > history_new.txt

# 合并最终上传列表
cat force_upload.txt history_new.txt | grep -v "^$" | sort -u > final_upload.txt

if [ ! -s final_upload.txt ]; then
  echo "没有需要上传的文件（根目录和merged都没变，也没新归档）"
  exit 0
fi

echo "本次将上传以下文件："
cat final_upload.txt
echo "----------------------------------------"

count=0
uploaded_new_history=""

# 【修复点】确保在循环开始前检查 Python 可用性
command -v python3 || { echo "Python 3 未找到，无法进行 URL 编码！"; exit 1; }

while IFS= read -r file; do
  # 跳过不存在的文件
  [[ -f "$file" ]] || continue
  
  # 关键：移除开头的 ./ 或 /。使用 ${file#./} 更安全。
  key="${file#./}"
  key="${key#/}"
  
  # 使用 Python 编码
  encoded_key=$(python3 -c "import urllib.parse, sys; sys.stdout.write(urllib.parse.quote('${key}', safe=''))")

  # 计数器和上传信息
  count=$((count + 1))
  echo "正在上传 ($count) $key"
  
  # 执行 CURL PUT
  HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -X PUT \
    "https://api.cloudflare.com/client/v4/accounts/$ACCOUNT_ID/storage/kv/namespaces/$NAMESPACE_ID/values/$encoded_key" \
    -H "Authorization: Bearer $API_TOKEN" \
    -H "Content-Type: text/plain" \
    --data-binary @"$file")

  if [[ "$HTTP_CODE" == "200" ]]; then
    echo "✅ 上传成功！"
    if [[ "$file" == history/* ]] && [[ "$file" != history/merged.* ]]; then
      uploaded_new_history="$uploaded_new_history$file\n"
    fi
  else
    echo "❌ 上传失败！HTTP 状态码: $HTTP_CODE"
    # 如果失败，这里会因为 set -e 而退出，但我们继续
  fi
  
  sleep 1.5
done < final_upload.txt

# ... (其余代码保持不变)
